<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>YOLOv8 Real-Time Object Detection</title>
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.19.0/dist/ort.min.js"></script>
  <style>
    *, ::before, ::after { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      min-height: 100vh; display: flex; flex-direction: column; align-items: center;
      justify-content: flex-start; padding: 60px 20px 40px 20px; color: #4a4a4a;
      background: linear-gradient(135deg, #f0f4f8, #d9e2ec); position: relative;
      overflow-x: hidden; overflow-y: auto; -webkit-overflow-scrolling: touch;
    }
    body::before {
      content: ''; position: fixed; top: -15%; left: -20%; width: 150%; height: 140%;
      pointer-events: none;
      background:
        radial-gradient(circle at 30% 30%, rgba(255, 206, 150, 0.4) 0%, transparent 60%),
        radial-gradient(circle at 75% 75%, rgba(179, 206, 255, 0.3) 0%, transparent 70%),
        radial-gradient(circle at 20% 80%, rgba(189, 243, 179, 0.25) 0%, transparent 70%);
      filter: blur(120px); z-index: -1;
    }
    body::after {
      content: ''; position: fixed; inset: 0;
      background:
        repeating-radial-gradient(circle at center, rgba(0,0,0,0.005) 0 2px, transparent 3px 5px),
        radial-gradient(circle, rgba(255,255,255,0.08) 1px, transparent 3px);
      z-index: -1; pointer-events: none; opacity: 0.2;
    }
    h1 {
      font-size: 2.8rem; font-weight: 700; color: #334e68; margin-bottom: 1rem; text-align: center;
      letter-spacing: 0.12em; text-transform: uppercase; text-shadow: 0 4px 12px rgba(255, 255, 255, 0.9);
    }
    .controls { text-align: center; margin-bottom: 24px; }
    button {
      background: linear-gradient(135deg, #86c8bc, #52b69a); color: #f0f4f8; border: none;
      border-radius: 999px; padding: 10px 24px; font-size: 1rem; font-weight: 600;
      margin: 0 6px; transition: background 0.3s ease, box-shadow 0.3s ease, transform 0.2s ease;
      cursor: pointer; box-shadow: 0 6px 18px rgba(82, 182, 154, 0.6); letter-spacing: 0.04em;
      touch-action: manipulation;
    }
    button:hover {
      background: linear-gradient(135deg, #52b69a, #38a3a5);
      box-shadow: 0 9px 32px rgba(56, 163, 165, 0.75);
      transform: translateY(-2px) scale(1.05);
    }
    button:active { transform: translateY(2px) scale(0.98); box-shadow: 0 4px 12px rgba(82, 182, 154, 0.45); }
    .main-content {
      display: flex; flex-direction: row; gap: 28px; justify-content: center;
      align-items: flex-start; padding: 0 30px; width: 100%; max-width: 960px;
    }
    .box {
      flex: 1 1 390px; aspect-ratio: 1/1; min-width: 300px; position: relative;
      margin-bottom: 10px; border-radius: 20px; background: rgba(0, 0, 0, 0.95);
      border: 1.5px solid rgba(132, 196, 191, 0.7);
      box-shadow: 0 12px 40px rgba(95, 178, 167, 0.26);
      display: flex; align-items: center; justify-content: center; overflow: hidden;
      touch-action: manipulation;
    }
    video, canvas {
      width: 100%; height: 100%; border-radius: 18px; object-fit: cover;
      position: relative; z-index: 1;
    }

    /* SUMMARY BELOW BOXES */
    .summary-wrapper {
      margin-top: 16px;
      width: 100%; max-width: 960px;
      background: rgba(255,255,255,0.85);
      border-radius: 16px;
      padding: 16px 20px;
      box-shadow: 0 6px 20px rgba(95, 178, 167, 0.25);
    }
    .summary-header {
      font-weight: 700; font-size: 1.1rem; color: #102a43; margin-bottom: 4px;
    }
    .summary-count { font-weight: 600; color: #1f6f8b; margin-bottom: 8px; }
    .summary-list { font-size: 0.95rem; color: #243b53; max-height: 140px; overflow-y: auto; }
    .summary-item { margin-bottom: 3px; }

    footer {
      margin-top: 24px; text-align: center; font-size: 0.92rem;
      color: #6e7e85; letter-spacing: 0.1em; font-weight: 500; padding-bottom: 20px;
    }
    @media (max-width: 900px) {
      .main-content { flex-direction: column; align-items: center; gap: 20px; padding: 0 10px; }
      .box { max-width: 94vw; min-width: unset; aspect-ratio: 4/3; flex: none; }
      h1 { font-size: 2.2rem; letter-spacing: 0.1em; }
      body { padding: 40px 20px 40px 20px; }
    }
    @media (max-width: 480px) {
      body { padding-top: 30px; }
      button { margin: 4px; width: 46%; padding: 12px 20px; font-size: 1.1rem; }
      h1 { font-size: 1.8rem; }
      .controls { margin-bottom: 18px; }
    }
  </style>
</head>
<body>
  <h1>REAL-TIME OBJECT DETECTION</h1>

  <div class="controls">
    <button id="start">Start Detection</button>
    <button id="stop">Stop Detection</button>
  </div>

  <div class="main-content">
    <div class="box" id="input-cam">
      <video id="video" autoplay playsinline muted></video>
    </div>
    <div class="box" id="output-cam">
      <canvas id="canvas"></canvas>
    </div>
  </div>

  <!-- SUMMARY BELOW BOXES -->
  <div class="summary-wrapper">
    <div class="summary-header">Detection Summary</div>
    <div id="summary-count" class="summary-count">No objects detected yet.</div>
    <div id="summary-list" class="summary-list"></div>
  </div>

  <footer>&copy; 2025 YOLOv8 Detection Demo</footer>

  <script>
    const startBtn = document.getElementById('start');
    const stopBtn = document.getElementById('stop');
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    const summaryCountEl = document.getElementById('summary-count');
    const summaryListEl = document.getElementById('summary-list');

    let stream = null;
    let running = false;
    let rafId = null;
    let session = null;
    let isDetecting = false;

    const COCOCLASSES = ['person','bicycle','car','motorcycle','airplane','bus','train','truck','boat','traffic light',
      'fire hydrant','stop sign','parking meter','bench','bird','cat','dog','horse','sheep','cow',
      'elephant','bear','zebra','giraffe','backpack','umbrella','handbag','tie','suitcase','frisbee',
      'skis','snowboard','sports ball','kite','baseball bat','baseball glove','skateboard','surfboard',
      'tennis racket','bottle','wine glass','cup','fork','knife','spoon','bowl','banana','apple',
      'sandwich','orange','broccoli','carrot','hot dog','pizza','donut','cake','chair','couch',
      'potted plant','bed','dining table','toilet','tv','laptop','mouse','remote','keyboard','cell phone',
      'microwave','oven','toaster','sink','refrigerator','book','clock','vase','scissors','teddy bear',
      'hair drier','toothbrush'];

    const OBJECT_DESCRIPTIONS = {
      'person':'Human individual - standing, walking, sitting, or lying',
      'bicycle':'Two-wheeled pedal-powered vehicle',
      'car':'Four-wheeled automobile - sedan, SUV, or hatchback',
      'motorcycle':'Two-wheeled motorized vehicle',
      'airplane':'Fixed-wing aircraft for air travel',
      'bus':'Large passenger vehicle for public transport',
      'train':'Railway passenger or freight carriage',
      'truck':'Large goods transport vehicle',
      'boat':'Watercraft for recreation or transport',
      'traffic light':'Road signal controlling vehicle traffic',
      'fire hydrant':'Emergency water supply for firefighting',
      'stop sign':'Octagonal red road traffic sign',
      'parking meter':'Coin-operated parking time regulator',
      'bench':'Outdoor seating for public use',
      'bird':'Feathered vertebrate animal',
      'cat':'Domestic feline pet - various breeds',
      'dog':'Domestic canine pet - various breeds',
      'horse':'Large hoofed mammal used for riding',
      'sheep':'Wool-producing farm animal',
      'cow':'Large dairy or beef farm animal',
      'elephant':'Large African or Asian mammal with trunk',
      'bear':'Large carnivorous mammal',
      'zebra':'Striped African equine mammal',
      'giraffe':'Tall African mammal with long neck',
      'backpack':'Carried bag with shoulder straps',
      'umbrella':'Portable rain protection canopy',
      'handbag':'Fashion accessory or utility bag',
      'tie':'Neckwear accessory for formal attire',
      'suitcase':'Rigid travel luggage with handle',
      'frisbee':'Plastic flying disc for games',
      'skis':'Long narrow equipment for snow gliding',
      'snowboard':'Single board for snow descent',
      'sports ball':'Spherical equipment for various sports',
      'kite':'Tethered flying toy or device',
      'baseball bat':'Wooden or metal hitting tool',
      'baseball glove':'Leather hand protection for catching',
      'skateboard':'Wheeled board for street sports',
      'surfboard':'Long board for wave riding',
      'tennis racket':'Strung paddle for tennis game',
      'bottle':'Glass or plastic liquid container',
      'wine glass':'Stemmed drinking glass',
      'cup':'Drinking vessel - mug or teacup',
      'fork':'Multi-pronged eating utensil',
      'knife':'Sharp-bladed cutting utensil',
      'spoon':'Concave eating utensil',
      'bowl':'Round deep serving or eating dish',
      'banana':'Curved yellow tropical fruit',
      'apple':'Round red or green fruit',
      'sandwich':'Bread slices with filling',
      'orange':'Round citrus fruit',
      'broccoli':'Green cruciferous vegetable',
      'carrot':'Orange root vegetable',
      'hot dog':'Sausage in bread bun',
      'pizza':'Flatbread with toppings',
      'donut':'Ring-shaped fried sweet pastry',
      'cake':'Baked sweet dessert',
      'chair':'Seating furniture - office, dining, or armchair',
      'couch':'Multi-person upholstered seating',
      'potted plant':'Indoor plant in decorative container',
      'bed':'Furniture for sleeping or resting',
      'dining table':'Large flat surface for meals',
      'toilet':'Sanitation fixture for waste disposal',
      'tv':'Flat-screen television display',
      'laptop':'Portable clamshell computer',
      'mouse':'Computer input pointing device',
      'remote':'Wireless device controller',
      'keyboard':'Computer text input device',
      'cell phone':'Mobile smartphone or communication device',
      'microwave':'Kitchen appliance for rapid heating',
      'oven':'Enclosed kitchen cooking appliance',
      'toaster':'Electric bread browning appliance',
      'sink':'Basin for washing dishes or hands',
      'refrigerator':'Electric food cooling appliance',
      'book':'Printed reading material - hardcover or paperback',
      'clock':'Timekeeping device - analog or digital',
      'vase':'Decorative flower container',
      'scissors':'Two-bladed cutting tool',
      'teddy bear':'Plush toy bear for children',
      'hair drier':'Electric hot air styling device',
      'toothbrush':'Oral hygiene cleaning tool'
    };

    async function initModel() {
      if (!session) {
        session = await ort.InferenceSession.create('static/yolov8n.onnx', {
          executionProviders: ['wasm']
        });
        console.log('YOLOv8 model loaded');
      }
    }

    function preprocessFrame() {
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = tempCanvas.height = 640;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(video, 0, 0, 640, 640);
      const imageData = tempCtx.getImageData(0, 0, 640, 640);
      const data = imageData.data;
      const input = new Float32Array(3 * 640 * 640);
      for (let i = 0, j = 0; i < data.length; i += 4, j++) {
        input[j] = data[i] / 255;
        input[j + 640 * 640] = data[i + 1] / 255;
        input[j + 2 * 640 * 640] = data[i + 2] / 255;
      }
      return input;
    }

    async function detect() {
      if (isDetecting || !session) return [];
      isDetecting = true;
      try {
        const inputTensor = new ort.Tensor('float32', preprocessFrame(), [1, 3, 640, 640]);
        const outputMap = await session.run({ images: inputTensor });
        const key = Object.keys(outputMap)[0];
        const out = outputMap[key];
        return postprocessFlexible(out);
      } catch (e) {
        console.error('Detect error', e);
        return [];
      } finally {
        isDetecting = false;
      }
    }

    function postprocessFlexible(out) {
      const numClasses = COCOCLASSES.length;
      const dims = out.dims;
      const data = out.data;
      const detections = [];
      const confThreshold = 0.25;
      const iouThreshold = 0.5;

      if (dims[1] === 84 && dims[2] === 8400) {
        const numPred = 8400;
        for (let i = 0; i < numPred; i++) {
          const cx = data[i];
          const cy = data[numPred + i];
          const w = data[2 * numPred + i];
          const h = data[3 * numPred + i];
          let bestScore = 0, bestId = -1;
          for (let c = 0; c < numClasses; c++) {
            const s = data[4 * numPred + c * numPred + i];
            if (s > bestScore) { bestScore = s; bestId = c; }
          }
          pushDet(detections, cx, cy, w, h, bestScore, bestId, confThreshold);
        }
      } else if (dims[1] === 8400 && dims[2] === 84) {
        const numPred = 8400;
        for (let i = 0; i < numPred; i++) {
          const offset = i * 84;
          const cx = data[offset + 0];
          const cy = data[offset + 1];
          const w = data[offset + 2];
          const h = data[offset + 3];
          let bestScore = 0, bestId = -1;
          for (let c = 0; c < numClasses; c++) {
            const s = data[offset + 4 + c];
            if (s > bestScore) { bestScore = s; bestId = c; }
          }
          pushDet(detections, cx, cy, w, h, bestScore, bestId, confThreshold);
        }
      }

      detections.sort((a, b) => b.score - a.score);
      const result = [];
      for (const det of detections) {
        if (result.every(r => iou(r, det) < iouThreshold)) result.push(det);
      }
      return result.slice(0, 20);
    }

    function pushDet(list, cx, cy, w, h, score, classId, confThreshold) {
      if (score < confThreshold || classId < 0) return;
      const MODEL_W = 640, MODEL_H = 640;
      const scaleX = canvas.width / MODEL_W;
      const scaleY = canvas.height / MODEL_H;
      const x1 = (cx - w / 2) * scaleX;
      const y1 = (cy - h / 2) * scaleY;
      const x2 = (cx + w / 2) * scaleX;
      const y2 = (cy + h / 2) * scaleY;
      list.push({
        x1, y1, x2, y2,
        label: COCOCLASSES[classId],
        score,
        widthPx: Math.round(x2 - x1),
        heightPx: Math.round(y2 - y1)
      });
    }

    function iou(a, b) {
      const x1 = Math.max(a.x1, b.x1);
      const y1 = Math.max(a.y1, b.y1);
      const x2 = Math.min(a.x2, b.x2);
      const y2 = Math.min(a.y2, b.y2);
      const inter = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
      const areaA = (a.x2 - a.x1) * (a.y2 - a.y1);
      const areaB = (b.x2 - b.x1) * (b.y2 - b.y1);
      return inter === 0 ? 0 : inter / (areaA + areaB - inter + 1e-6);
    }

    async function startCamera() {
      const constraints = { video: true, audio: false };
      stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;

      // Ensure metadata loaded to avoid zero width/height
      await new Promise(res => {
        video.onloadedmetadata = () => res();
      });
      await video.play();

      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;

      await initModel();
    }

    async function loop() {
      if (!running) return;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      const detections = await detect();
      const objectCount = detections.length;

      // Update summary below boxes
      if (objectCount === 0) {
        summaryCountEl.textContent = 'No objects detected.';
        summaryListEl.innerHTML = '';
      } else {
        summaryCountEl.textContent = `${objectCount} object(s) detected.`;
        const counts = {};
        detections.forEach(d => {
          counts[d.label] = (counts[d.label] || 0) + 1;
        });
        const lines = [];
        Object.entries(counts).forEach(([label, count]) => {
          const desc = OBJECT_DESCRIPTIONS[label] || 'Detected object';
          lines.push(`<div class="summary-item">${count}× <strong>${label}</strong> — ${desc}</div>`);
        });
        summaryListEl.innerHTML = lines.join('');
      }

      // Draw boxes with descriptions
      detections.forEach(det => {
        const { x1, y1, x2, y2, label, score, widthPx, heightPx } = det;
        const description = OBJECT_DESCRIPTIONS[label] || 'Detected object';

        ctx.lineWidth = 3;
        ctx.strokeStyle = 'rgba(82, 182, 154, 0.9)';
        ctx.fillStyle = 'rgba(82, 182, 154, 0.25)';
        ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
        ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);

        const labelText = `${label} ${(score * 100).toFixed(1)}%`;
        ctx.font = '16px Segoe UI, Tahoma, Geneva, Verdana, sans-serif';
        const labelWidth = ctx.measureText(labelText).width + 10;
        ctx.fillStyle = 'rgba(82, 182, 154, 0.95)';
        ctx.fillRect(x1, y1 - 40, labelWidth, 20);
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'left';
        ctx.fillText(labelText, x1 + 5, y1 - 25);

        const descText = description;
        ctx.font = '13px Segoe UI, Tahoma, Geneva, Verdana, sans-serif';
        const descWidth = ctx.measureText(descText).width + 10;
        ctx.fillStyle = 'rgba(51, 110, 123, 0.95)';
        ctx.fillRect(x1, y1 - 20, Math.max(labelWidth, descWidth), 18);
        ctx.fillStyle = '#f0f8ff';
        ctx.fillText(descText, x1 + 5, y1 - 7);

        const sizeText = `${widthPx}×${heightPx}px`;
        ctx.font = '12px Segoe UI, Tahoma, Geneva, Verdana, sans-serif';
        const sizeWidth = ctx.measureText(sizeText).width + 8;
        ctx.fillStyle = 'rgba(82, 182, 154, 0.9)';
        ctx.fillRect(x1, y2 + 2, sizeWidth, 16);
        ctx.fillStyle = '#fff';
        ctx.fillText(sizeText, x1 + 4, y2 + 14);
      });

      rafId = requestAnimationFrame(loop);
    }

    startBtn.onclick = async () => {
      if (running) return;
      try {
        await startCamera();
        running = true;
        loop();
      } catch (error) {
        console.error('Camera error', error);
        alert('Error accessing webcam: ' + error.name + ' ' + error.message);
      }
    };

    stopBtn.onclick = () => {
      running = false;
      if (rafId) cancelAnimationFrame(rafId);
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      summaryCountEl.textContent = 'Detection stopped.';
      summaryListEl.innerHTML = '';
    };
  </script>
</body>
</html>

